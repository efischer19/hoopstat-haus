---
title: "ADR-017: Application Configuration and AWS Resource Discovery"
status: "Proposed"
date: "2025-01-28"
tags:
  - "configuration"
  - "aws"
  - "applications"
  - "resource-discovery"
---

## Context

* **Problem:** Python applications in the Hoopstat Haus project need a consistent and secure method to discover and connect to AWS resources (S3 buckets, ECR repositories, etc.) without hardcoding resource names or requiring manual configuration for each deployment.
* **Constraints:** Must support the single production environment strategy (ADR-012), work with GitHub Actions CI/CD workflows, provide flexibility for different application types, maintain security through least-privilege access, align with Python application standards, and enable easy local development and testing.

## Decision

We will use **environment variables with standardized naming conventions and optional configuration files** for applications to discover AWS resources, combined with **AWS resource tagging** for programmatic discovery.

## Considered Options

1. **Environment Variables with Standardized Naming (The Chosen One):** Configuration through environment variables following consistent patterns.
   * *Pros:* Twelve-factor app compliant, works seamlessly with Docker and GitHub Actions, easy to override for testing, no additional dependencies, secure (no credentials in code), flexible for different deployment scenarios, integrates well with existing CI/CD workflows
   * *Cons:* Can become unwieldy with many resources, requires discipline in naming conventions, limited support for complex nested configuration, environment variable explosion for large applications

2. **AWS Systems Manager Parameter Store:** Store configuration in AWS native parameter service.
   * *Pros:* Native AWS integration with IAM security, supports hierarchical parameters, encryption for sensitive values, audit logging, centralized configuration management
   * *Cons:* Additional dependency on AWS service, requires network calls during application startup, more complex than environment variables, vendor lock-in to AWS, potential latency during initialization

3. **Configuration Files with AWS S3:** Store config files in S3 and download at runtime.
   * *Pros:* Supports complex configuration structures, version control for configuration, centralized configuration management, can include non-sensitive documentation
   * *Cons:* Requires S3 access during startup, potential security risks if misconfigured, complexity in configuration versioning, dependency on S3 availability for app startup

4. **Service Discovery through AWS Tags:** Query AWS APIs to discover resources by tags.
   * *Pros:* Dynamic resource discovery, no hardcoded resource names, supports infrastructure changes transparently, leverages AWS native capabilities
   * *Cons:* Requires broad AWS permissions for discovery, network calls during startup, potential performance impact, complex error handling for missing resources

## Configuration Framework

### Environment Variable Naming Convention
```bash
# Resource naming pattern
AWS_REGION=us-east-1
AWS_S3_BUCKET_<PURPOSE>=bucket-name
AWS_ECR_REPOSITORY=repository-uri

# Application-specific examples
AWS_S3_BUCKET_RAW_DATA=hoopstat-haus-raw-data-prod
AWS_S3_BUCKET_PROCESSED_DATA=hoopstat-haus-processed-data-prod
AWS_S3_BUCKET_BACKUP=hoopstat-haus-backup-prod
AWS_ECR_REPOSITORY=123456789.dkr.ecr.us-east-1.amazonaws.com/hoopstat-haus/data-pipeline
```

### Optional Configuration File Support
```yaml
# config/aws.yml (optional, supplements environment variables)
aws:
  region: ${AWS_REGION}
  s3:
    buckets:
      raw_data: ${AWS_S3_BUCKET_RAW_DATA}
      processed_data: ${AWS_S3_BUCKET_PROCESSED_DATA}
      backup: ${AWS_S3_BUCKET_BACKUP}
  ecr:
    repository: ${AWS_ECR_REPOSITORY}
```

### Python Configuration Utility
```python
# shared utility for AWS configuration
import os
from typing import Optional

class AWSConfig:
    def __init__(self):
        self.region = os.getenv("AWS_REGION", "us-east-1")
        
    def get_s3_bucket(self, purpose: str) -> str:
        """Get S3 bucket name for specific purpose"""
        env_var = f"AWS_S3_BUCKET_{purpose.upper()}"
        bucket = os.getenv(env_var)
        if not bucket:
            raise ValueError(f"Missing required environment variable: {env_var}")
        return bucket
        
    def get_ecr_repository(self) -> str:
        """Get ECR repository URI"""
        repo = os.getenv("AWS_ECR_REPOSITORY")
        if not repo:
            raise ValueError("Missing required environment variable: AWS_ECR_REPOSITORY")
        return repo
```

## Consequences

* **Positive:** Simple and familiar configuration pattern for developers, twelve-factor app compliance improves deployment flexibility, easy to test and override for different environments, no additional AWS service dependencies, works seamlessly with existing Docker and GitHub Actions workflows, secure by design with no credentials in code.
* **Negative:** Potential for environment variable proliferation with many AWS resources, requires discipline in naming convention consistency, limited support for complex nested configuration without additional tooling, manual coordination between infrastructure creation and application configuration.
* **Future Implications:** All Python applications will follow consistent configuration patterns enabling standardized deployment workflows, Terraform infrastructure must output environment variables for application configuration, shared configuration utilities can evolve to support more complex scenarios, future applications can leverage established patterns reducing development overhead.