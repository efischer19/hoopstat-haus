---
name: Build and Push to ECR

on:
  push:
    branches: [main]
    paths:
      - 'apps/**'
  pull_request:
    branches: [main]
    paths:
      - 'apps/**'
  workflow_dispatch:
    inputs:
      force_build:
        description: 'Force build all apps (true/false)'
        required: false
        default: 'false'

env:
  AWS_REGION: us-east-1

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.changes.outputs.matrix }}
      has-changes: ${{ steps.changes.outputs.has-changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed apps
        id: changes
        run: |
          # Force build all apps if requested
          if [[ "${{ github.event.inputs.force_build }}" == "true" ]]; then
            echo "🔄 Force building all applications"
            changed_files=$(find apps -maxdepth 1 -type d | grep -v "^apps$" | cut -d'/' -f2)
          else
            # Get list of changed files in apps directory
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              BASE_SHA="${{ github.event.pull_request.base.sha }}"
            else
              BASE_SHA="HEAD~1"
            fi
            
            changed_files=$(git diff --name-only ${BASE_SHA}...HEAD | \
              grep '^apps/' | cut -d'/' -f2 | sort -u)
          fi

          if [ -z "$changed_files" ]; then
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            echo "No changes detected in apps directory"
          else
            echo "has-changes=true" >> $GITHUB_OUTPUT

            # Build matrix of changed apps
            matrix_items=""
            for app in $changed_files; do
              if [ -f "apps/$app/pyproject.toml" ] && [ -f "apps/$app/Dockerfile" ]; then
                if [ -n "$matrix_items" ]; then
                  matrix_items="$matrix_items,"
                fi
                matrix_items="$matrix_items{\"app\":\"$app\"}"
              fi
            done

            if [ -n "$matrix_items" ]; then
              echo "matrix={\"include\":[$matrix_items]}" >> $GITHUB_OUTPUT
              echo "Found apps to build: $changed_files"
            else
              echo "has-changes=false" >> $GITHUB_OUTPUT
              echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
              echo "No buildable apps found in changed directories"
            fi
          fi

  build-and-push:
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          role-session-name: GitHubActions-BuildPush-${{ matrix.app }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate image tags
        id: meta
        run: |
          # Generate tags based on ADR-018 Container Image Naming and Tagging Strategy
          GIT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%s)
          
          REPOSITORY_URI="${{ steps.login-ecr.outputs.registry }}/hoopstat-haus/${{ matrix.app }}"
          
          # Primary tag: git commit SHA
          TAGS="${REPOSITORY_URI}:git-${GIT_SHA}"
          
          # Add latest tag for main branch builds
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAGS="${TAGS},${REPOSITORY_URI}:latest"
          fi
          
          # Add semantic version tag if this is a release
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
            TAGS="${TAGS},${REPOSITORY_URI}:${VERSION}"
          fi
          
          # Add branch tag for non-main branches
          if [[ "${{ github.ref }}" != "refs/heads/main" ]] && [[ "${{ github.ref }}" == refs/heads/* ]]; then
            BRANCH=${GITHUB_REF#refs/heads/}
            BRANCH_TAG=$(echo "$BRANCH" | sed 's/[^a-zA-Z0-9.-]/-/g')
            TAGS="${TAGS},${REPOSITORY_URI}:branch-${BRANCH_TAG}"
          fi
          
          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "repository-uri=${REPOSITORY_URI}" >> $GITHUB_OUTPUT
          echo "git-sha=${GIT_SHA}" >> $GITHUB_OUTPUT
          
          echo "🏷️  Generated tags:"
          echo "${TAGS}" | tr ',' '\n' | sed 's/^/  - /'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: apps/${{ matrix.app }}
          file: apps/${{ matrix.app }}/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.title=${{ matrix.app }}
            org.opencontainers.image.description=Hoopstat Haus ${{ matrix.app }} application
            org.opencontainers.image.source=${{ github.repositoryUrl }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: Generate deployment artifacts
        run: |
          # Generate deployment configuration for this build
          mkdir -p deployment-artifacts
          
          cat > deployment-artifacts/${{ matrix.app }}-deployment.yml << EOF
          # Deployment configuration for ${{ matrix.app }}
          # Generated by GitHub Actions on $(date -u)
          
          application: ${{ matrix.app }}
          image: ${{ steps.meta.outputs.repository-uri }}:git-${{ steps.meta.outputs.git-sha }}
          git_sha: ${{ steps.meta.outputs.git-sha }}
          build_timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          github_run_id: ${{ github.run_id }}
          
          # Environment variables for application
          environment:
            AWS_REGION: ${{ env.AWS_REGION }}
            AWS_S3_BUCKET_RAW_DATA: \${{ vars.AWS_S3_BUCKET_RAW_DATA }}
            AWS_S3_BUCKET_PROCESSED_DATA: \${{ vars.AWS_S3_BUCKET_PROCESSED_DATA }}
            AWS_S3_BUCKET_BACKUP: \${{ vars.AWS_S3_BUCKET_BACKUP }}
          EOF
          
          echo "📦 Generated deployment configuration:"
          cat deployment-artifacts/${{ matrix.app }}-deployment.yml

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-config-${{ matrix.app }}
          path: deployment-artifacts/
          retention-days: 30

      - name: Image vulnerability scan
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          # Run basic security scan on the built image
          echo "🔍 Running vulnerability scan..."
          
          # Note: In a real setup, you might use tools like:
          # - Trivy: docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image
          # - Snyk: snyk container test
          # - AWS ECR native scanning (enabled in Terraform)
          
          echo "✅ Vulnerability scan completed (placeholder)"

  deploy-to-production:
    needs: [detect-changes, build-and-push]
    if: github.ref == 'refs/heads/main' && needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    
    permissions:
      id-token: write
      contents: read
    
    environment:
      name: production
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download deployment artifacts
        uses: actions/download-artifact@v4
        with:
          name: deployment-config-${{ matrix.app }}
          path: deployment-artifacts/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_DATA_PIPELINE_ROLE_ARN }}
          role-session-name: GitHubActions-Deploy-${{ matrix.app }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy application
        run: |
          echo "🚀 Deploying ${{ matrix.app }} to production..."
          
          # Load deployment configuration
          DEPLOYMENT_CONFIG="deployment-artifacts/${{ matrix.app }}-deployment.yml"
          
          if [ -f "$DEPLOYMENT_CONFIG" ]; then
            echo "📋 Deployment configuration:"
            cat "$DEPLOYMENT_CONFIG"
          else
            echo "❌ Deployment configuration not found!"
            exit 1
          fi
          
          # For now, this is a placeholder for actual deployment logic
          # In a real scenario, this might:
          # - Deploy to ECS/Fargate
          # - Update Kubernetes deployments
          # - Trigger AWS Lambda deployments
          # - Update application configuration
          
          echo "✅ Deployment completed successfully!"
          echo "🎉 ${{ matrix.app }} is now running in production"

      - name: Tag production deployment
        run: |
          # Tag the deployed image as 'prod' for easy identification
          GIT_SHA=$(git rev-parse --short HEAD)
          
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ vars.ECR_REGISTRY }}
          
          REPOSITORY_URI="${{ vars.ECR_REGISTRY }}/hoopstat-haus/${{ matrix.app }}"
          
          # Pull the git-sha tagged image
          docker pull "${REPOSITORY_URI}:git-${GIT_SHA}"
          
          # Tag as production
          docker tag "${REPOSITORY_URI}:git-${GIT_SHA}" "${REPOSITORY_URI}:prod"
          
          # Push production tag
          docker push "${REPOSITORY_URI}:prod"
          
          echo "✅ Tagged ${REPOSITORY_URI}:prod"

  cleanup:
    needs: [detect-changes, build-and-push]
    if: always() && needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          role-session-name: GitHubActions-Cleanup
          aws-region: ${{ env.AWS_REGION }}

      - name: Cleanup old images
        run: |
          echo "🧹 Cleaning up old container images..."
          
          # This is handled by ECR lifecycle policies defined in Terraform
          # But we can also do immediate cleanup of very old images here
          
          echo "✅ Cleanup completed (handled by ECR lifecycle policies)"