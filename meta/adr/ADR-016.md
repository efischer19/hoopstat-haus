---
title: "ADR-016: Shared Python Library Strategy for Common Code"
status: "Accepted"
date: "2025-01-27"
tags:
  - "python"
  - "libraries"
  - "monorepo"
  - "code-reuse"
  - "dry-principle"
---

## Context

* **Problem:** Multiple Python applications in the Hoopstat Haus monorepo need to share common utilities like performance monitoring code. Currently, the performance monitoring utilities from ADR-015 exist only in the Python app template, leading to code duplication when multiple applications are created. This violates the DRY (Don't Repeat Yourself) principle and creates maintenance overhead when common code needs updates.

* **Constraints:** Must maintain simplicity and align with the project's development philosophy of favoring static-first design and minimal complexity. Solution should work well within the existing monorepo structure and Poetry-based dependency management. Must not break existing applications or significantly complicate the development workflow.

## Decision

We will create a **shared Python library package** within the monorepo under `libs/hoopstat-common/` that contains common utilities and can be consumed by Python applications as a local dependency.

## Considered Options

1. **Shared Library Package in Monorepo (The Chosen One):** Create a `libs/hoopstat-common/` directory with a proper Python package that applications can depend on via Poetry's path dependencies.
   * *Pros:* Clean separation of concerns, proper Python packaging conventions, easy to version and evolve, works seamlessly with Poetry dependency management, enables proper testing of shared code, maintains monorepo benefits while providing structure, allows gradual migration of existing apps
   * *Cons:* Slight increase in complexity with dependency management, requires proper package structure and versioning strategy

2. **Simple Module Sharing:** Create a `common/` directory with shared Python modules that apps import directly via Python path manipulation.
   * *Pros:* Minimal setup overhead, very simple implementation, no dependency management complexity
   * *Cons:* Brittle import mechanisms, difficult to version shared code, poor separation of concerns, potential Python path conflicts, harder to test shared code in isolation

3. **Internal PyPI/Package Repository:** Create proper Python packages and host them in an internal package repository.
   * *Pros:* Professional approach with proper versioning, can be reused outside the monorepo, follows industry standards
   * *Cons:* Significant complexity overhead for the current scale, requires infrastructure for package hosting, overkill for internal-only common code

4. **Git Submodules:** Separate repository for common code included as Git submodules.
   * *Pros:* True separation allows reuse across projects, can be independently versioned
   * *Cons:* Git submodule complexity and maintenance overhead, breaks monorepo simplicity, complicates developer workflow

## Consequences

* **Positive:** Eliminates code duplication across Python applications, provides a clear pattern for sharing common utilities, enables proper testing and versioning of shared code, maintains monorepo benefits while adding structure, allows incremental adoption without breaking existing apps, simplifies maintenance of common utilities like performance monitoring.

* **Negative:** Slight increase in project complexity with additional package to maintain, requires developers to understand Poetry path dependencies, creates dependency relationships between applications and shared library.

* **Future Implications:** All new Python applications should consume shared utilities from `hoopstat-common` rather than duplicating code. Existing applications can migrate to shared library incrementally. Additional common utilities (logging helpers, configuration management, data processing utilities) can be added to the shared library as they are identified. Versioning strategy may be needed if breaking changes are required in shared library.