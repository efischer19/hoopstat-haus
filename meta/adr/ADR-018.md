---
title: "ADR-018: Container Image Naming and Tagging Strategy"
status: "Proposed"
date: "2025-01-28"
tags:
  - "docker"
  - "ecr"
  - "containers"
  - "versioning"
  - "deployment"
---

## Context

* **Problem:** With Docker containerization (ADR-006) and AWS ECR for container storage (ADR-009), we need a consistent strategy for naming and tagging container images that supports reliable deployments, easy rollbacks, and clear tracking of deployed versions across our GitHub Actions CI/CD workflows.
* **Constraints:** Must integrate with GitHub Actions workflows, support the single production environment strategy (ADR-012), enable easy identification of deployed versions, support rollback scenarios, align with AWS ECR best practices, and work with the existing monorepo structure (ADR-008).

## Decision

We will use **semantic versioning with git commit SHA and environment-specific tags** for container images, following a standardized naming convention that combines repository structure with application identity.

## Container Image Naming Convention

### Repository Naming Pattern
```
<registry>/<project>/<app-name>
```

### Examples
```
123456789.dkr.ecr.us-east-1.amazonaws.com/hoopstat-haus/data-pipeline
123456789.dkr.ecr.us-east-1.amazonaws.com/hoopstat-haus/stats-api
123456789.dkr.ecr.us-east-1.amazonaws.com/hoopstat-haus/web-dashboard
```

### Tagging Strategy

1. **Git Commit SHA (Primary)**: `git-<short-sha>` (e.g., `git-a1b2c3d`)
   - Immutable reference to exact code version
   - Enables precise tracking and debugging
   - Used for production deployments

2. **Semantic Version Tags**: `v<major>.<minor>.<patch>` (e.g., `v1.0.0`)
   - Applied when creating GitHub releases
   - Human-readable version identification
   - Used for release management

3. **Environment Tags**: `prod`, `latest`
   - `prod`: Currently deployed in production
   - `latest`: Most recent successful build from main branch

4. **Branch Tags**: `branch-<branch-name>` (e.g., `branch-feature-xyz`)
   - For feature branch testing and development
   - Temporary tags, cleaned up after branch merge/deletion

## Considered Options

1. **Git SHA + Semantic Versioning + Environment Tags (The Chosen One):** Multi-tag strategy for different use cases.
   * *Pros:* Precise tracking with git SHA, human-readable semantic versions, easy environment identification, supports rollback scenarios, integrates well with GitHub releases, provides flexibility for different deployment needs
   * *Cons:* Multiple tags per image increases complexity, requires tag management and cleanup processes, potential for tag confusion without clear conventions

2. **Git SHA Only:** Use only git commit SHA for all tagging.
   * *Pros:* Simple and unambiguous, directly traceable to source code, no tag management complexity, immutable references
   * *Cons:* Poor human readability, difficult to identify major/minor releases, no easy way to identify "current production" without external tracking

3. **Semantic Versioning Only:** Use only semantic version tags.
   * *Pros:* Clear human-readable versions, follows established conventions, easy release management, good for external communication
   * *Cons:* Requires manual version bumping, potential for human error in versioning, doesn't directly tie to source code commits, challenging for continuous deployment

4. **Timestamp-Based Tagging:** Use build timestamp for image tags.
   * *Pros:* Automatically generated, chronological ordering, simple automation
   * *Cons:* No connection to source code version, difficult to correlate with features or bug fixes, poor developer experience, challenging for rollbacks

## GitHub Actions Integration

### Build and Tag Workflow
```yaml
- name: Build and tag Docker image
  run: |
    # Generate tags
    GIT_SHA=$(git rev-parse --short HEAD)
    IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}"
    
    # Build with multiple tags
    docker build -t "${IMAGE_URI}:git-${GIT_SHA}" .
    docker tag "${IMAGE_URI}:git-${GIT_SHA}" "${IMAGE_URI}:latest"
    
    # Tag with semantic version if this is a release
    if [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
      VERSION=${GITHUB_REF#refs/tags/}
      docker tag "${IMAGE_URI}:git-${GIT_SHA}" "${IMAGE_URI}:${VERSION}"
    fi
    
    # Push all tags
    docker push "${IMAGE_URI}" --all-tags
```

### Production Deployment Tagging
```yaml
- name: Tag production deployment
  run: |
    GIT_SHA=$(git rev-parse --short HEAD)
    IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}"
    
    # Pull and retag for production
    docker pull "${IMAGE_URI}:git-${GIT_SHA}"
    docker tag "${IMAGE_URI}:git-${GIT_SHA}" "${IMAGE_URI}:prod"
    docker push "${IMAGE_URI}:prod"
```

## Tag Lifecycle Management

### Retention Policy
- **Git SHA tags**: Keep all (for debugging and rollback)
- **Semantic version tags**: Keep all (permanent release markers)
- **Environment tags**: Keep latest only (moving targets)
- **Branch tags**: Delete after branch cleanup (temporary)

### Cleanup Automation
```yaml
- name: Cleanup old branch tags
  run: |
    # Remove tags for deleted branches
    # Implemented in scheduled cleanup workflow
```

## Consequences

* **Positive:** Clear traceability from deployed containers to source code commits, flexible tagging supports different deployment scenarios, semantic versions provide human-readable release identification, environment tags enable easy identification of current deployments, integrates seamlessly with GitHub Actions and release processes, supports reliable rollback scenarios.
* **Negative:** Multiple tags per image require disciplined management, potential for confusion without clear tagging conventions, requires tag cleanup processes to prevent repository bloat, slight increase in CI/CD complexity for tag management, coordination needed between release process and tagging strategy.
* **Future Implications:** All container builds will follow consistent tagging patterns enabling reliable deployment automation, deployment tools can use predictable tag patterns for version identification, rollback processes can leverage git SHA tags for precise version targeting, release management can leverage semantic version tags for clear communication, monitoring and observability can use tag information for deployment tracking.